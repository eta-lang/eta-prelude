<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Eta</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Eta.html");};
//]]>
</script></head><body class="no-frame"><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Eta</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Concepts</a><ul><li><a href="#g:2">Pipe operators</a><ul><li><a href="#g:3">Pipe backwards</a></li></ul></li><li><a href="#g:4">Functor</a><ul><li><a href="#g:5">Map forward</a></li><li><a href="#g:6">Map backwards</a></li><li><a href="#g:7">Discard</a></li></ul></li><li><a href="#g:8">Applicative</a><ul><li><a href="#g:9">Apply forward</a></li><li><a href="#g:10">Apply backwards</a></li></ul></li><li><a href="#g:11">Monad</a><ul><li><a href="#g:12">Flatmap forward</a></li><li><a href="#g:13">Flatmap backwards</a></li></ul></li><li><a href="#g:14">Monoid</a><ul><li><a href="#g:15">Monoid neutral element</a></li><li><a href="#g:16">Monoid reduction</a></li><li><a href="#g:17">Append operator</a></li></ul></li><li><a href="#g:18">Foldable</a><ul><li><a href="#g:19">foldLeft</a></li><li><a href="#g:20">strictFoldRight</a></li><li><a href="#g:21">strictFoldLeft</a></li><li><a href="#g:22">monadicFoldRight</a></li><li><a href="#g:23">monadicFoldLeft</a></li><li><a href="#g:24">foldMap</a></li><li><a href="#g:25">toList</a></li><li><a href="#g:26">isEmpty</a></li><li><a href="#g:27">length</a></li><li><a href="#g:28">isElementOf</a></li><li><a href="#g:29">maximum</a></li><li><a href="#g:30">maximumBy</a></li><li><a href="#g:31">unsafeMaximum</a></li><li><a href="#g:32">minimum</a></li><li><a href="#g:33">minimumBy</a></li><li><a href="#g:34">unsafeMinimum</a></li><li><a href="#g:35">sum</a></li><li><a href="#g:36">product</a></li><li><a href="#g:37">findBy</a></li><li><a href="#g:38">any</a></li><li><a href="#g:39">all</a></li></ul></li><li><a href="#g:40">Acting on Foldables</a><ul><li><a href="#g:41">foreach</a></li></ul></li><li><a href="#g:42">Traversable</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The Eta Prelude</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:-124--62-">(|&gt;)</a> :: a -&gt; (a -&gt; b) -&gt; b</li><li class="src short"><a href="#v:-60--124-">(&lt;|)</a> :: (a -&gt; b) -&gt; a -&gt; b</li><li class="src short"><a href="#v:map">map</a> :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-124--36--62-">(|$&gt;)</a> :: Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b</li><li class="src short"><a href="#v:-60--36--124-">(&lt;$|)</a> :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:discard">discard</a> :: Functor f =&gt; f a -&gt; f ()</li><li class="src short"><a href="#v:apply">apply</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-124--42--62-">(|*&gt;)</a> :: Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b</li><li class="src short"><a href="#v:-60--42--124-">(&lt;*|)</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:flatMap">flatMap</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</li><li class="src short"><a href="#v:-124--62--62-">(|&gt;&gt;)</a> :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:-60--60--124-">(&lt;&lt;|)</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</li><li class="src short"><a href="#v:append">append</a> :: Monoid a =&gt; a -&gt; a -&gt; a</li><li class="src short"><a href="#v:neutral">neutral</a> :: Monoid a =&gt; a</li><li class="src short"><a href="#v:concat">concat</a> :: Monoid a =&gt; [a] -&gt; a</li><li class="src short"><a href="#v:-60--43--62-">(&lt;+&gt;)</a> :: Monoid a =&gt; a -&gt; a -&gt; a</li><li class="src short"><a href="#v:foldRight">foldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:foldLeft">foldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:strictFoldRight">strictFoldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:strictFoldLeft">strictFoldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:monadicFoldRight">monadicFoldRight</a> :: (Foldable f, Monad m) =&gt; (a -&gt; b -&gt; m b) -&gt; b -&gt; f a -&gt; m b</li><li class="src short"><a href="#v:monadicFoldLeft">monadicFoldLeft</a> :: (Foldable f, Monad m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; f a -&gt; m b</li><li class="src short"><a href="#v:foldMap">foldMap</a> :: (Foldable f, Monoid m) =&gt; (a -&gt; m) -&gt; f a -&gt; m</li><li class="src short"><a href="#v:toList">toList</a> :: Foldable f =&gt; f a -&gt; [a]</li><li class="src short"><a href="#v:isEmpty">isEmpty</a> :: Foldable f =&gt; f a -&gt; Bool</li><li class="src short"><a href="#v:length">length</a> :: Foldable f =&gt; f a -&gt; Int</li><li class="src short"><a href="#v:isElementOf">isElementOf</a> :: (Eq a, Foldable f) =&gt; a -&gt; f a -&gt; Bool</li><li class="src short"><a href="#v:maximum">maximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; Maybe a</li><li class="src short"><a href="#v:maximumBy">maximumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; Maybe a</li><li class="src short"><a href="#v:unsafeMaximum">unsafeMaximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:minimum">minimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; Maybe a</li><li class="src short"><a href="#v:minimumBy">minimumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; Maybe a</li><li class="src short"><a href="#v:unsafeMinimum">unsafeMinimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:sum">sum</a> :: (Num a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:product">product</a> :: (Num a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:findBy">findBy</a> :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; Maybe a</li><li class="src short"><a href="#v:any">any</a> :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; Bool</li><li class="src short"><a href="#v:all">all</a> :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; Bool</li><li class="src short"><a href="#v:discardTraverse">discardTraverse</a> :: (Foldable f, Applicative m) =&gt; (a -&gt; m b) -&gt; f a -&gt; m ()</li><li class="src short"><a href="#v:foreach">foreach</a> :: (Foldable f, Applicative m) =&gt; f a -&gt; (a -&gt; m b) -&gt; m ()</li></ul></div><div id="interface"><h1 id="g:1">Concepts</h1><h2 id="g:2">Pipe operators</h2><div class="top"><p class="src"><a id="v:-124--62-" class="def">(|&gt;)</a> :: a -&gt; (a -&gt; b) -&gt; b <a href="#v:-124--62-" class="selflink">#</a></p><div class="doc"><p>Functions can be applied using the pipe operators,
reducing parentheses and increasing the code readability.</p><p>Instead of writing</p><pre>  (putStrLn (join &quot;, &quot; (sort names)))
</pre><p>Use the pipe operators:</p><pre>  names
    |&gt; sort
    |&gt; join &quot;, &quot;
    |&gt; putStrLn
</pre></div></div><h3 id="g:3">Pipe backwards</h3><div class="top"><p class="src"><a id="v:-60--124-" class="def">(&lt;|)</a> :: (a -&gt; b) -&gt; a -&gt; b <a href="#v:-60--124-" class="selflink">#</a></p><div class="doc"><p>Applies the function of the left to the value of the right.</p><pre>  &gt;&gt;&gt; + 2 &lt;| 1
  3
</pre></div></div><h2 id="g:4">Functor</h2><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b <a href="#v:map" class="selflink">#</a></p><div class="doc"><p>The <code>Functor</code> type class defines that a type
can have a <code><a href="Eta.html#v:map">map</a></code> operation which can be used
to map a function over the elements of it.</p><p>The list and the <code>Maybe</code> types are examples of
instances of <code>Functor</code>.</p><pre>  &gt;&gt;&gt; map (+1) [1, 2, 3]
  [2, 3, 4]
</pre><p><em>Mnemonic: Mappable</em></p></div></div><h3 id="g:5">Map forward</h3><div class="top"><p class="src"><a id="v:-124--36--62-" class="def">(|$&gt;)</a> :: Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b <a href="#v:-124--36--62-" class="selflink">#</a></p><div class="doc"><p>Maps the function of the right to the Functor of the left:</p><pre>  &gt;&gt;&gt; [1, 2, 3] |$&gt; (+ 1)
  [2, 3, 4]
</pre></div></div><h3 id="g:6">Map backwards</h3><div class="top"><p class="src"><a id="v:-60--36--124-" class="def">(&lt;$|)</a> :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b <a href="#v:-60--36--124-" class="selflink">#</a></p><div class="doc"><p>Maps the function of the left to the Functor of the right:</p><pre>  &gt;&gt;&gt; (+1) &lt;$| [1, 2, 3]
  [2, 3, 4]
</pre></div></div><h3 id="g:7">Discard</h3><div class="top"><p class="src"><a id="v:discard" class="def">discard</a> :: Functor f =&gt; f a -&gt; f () <a href="#v:discard" class="selflink">#</a></p><div class="doc"><p>Discards the value inside of the functor.</p><pre>  &gt;&gt;&gt; discard [1, 2, 3]
  [(), (), ()]
</pre></div></div><h2 id="g:8">Applicative</h2><div class="top"><p class="src"><a id="v:apply" class="def">apply</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b <a href="#v:apply" class="selflink">#</a></p><div class="doc"><p>The <code>Applicative</code> type class defines that a type
can have an <code><a href="Eta.html#v:apply">apply</a></code> operation which can be used
to apply a function contained in the <code>Applicative</code>
to the elements of Another.</p><p>All types that implement <code>Applicative</code> must implement
<code>Functor</code>.</p><p>The <code>Maybe</code> type is an example of
an instance of <code>Applicative</code>.</p><pre>  &gt;&gt;&gt; apply (Just (+1)) (Just 2)
  Just 3
</pre><p><em>Mnemonic: Applyable</em></p></div></div><h3 id="g:9">Apply forward</h3><div class="top"><p class="src"><a id="v:-124--42--62-" class="def">(|*&gt;)</a> :: Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b <a href="#v:-124--42--62-" class="selflink">#</a></p><div class="doc"><p>Applies the function contained in the Applicative of the right
to the Applicative which contains a value of the left:</p><pre>  &gt;&gt;&gt; Just 1 |*&gt; Just (+2)
  Just 3
</pre></div></div><h3 id="g:10">Apply backwards</h3><div class="top"><p class="src"><a id="v:-60--42--124-" class="def">(&lt;*|)</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b <a href="#v:-60--42--124-" class="selflink">#</a></p><div class="doc"><p>Applies the function contained in the Applicative of the left
to the Applicative which contains a value of the right:</p><pre>  &gt;&gt;&gt; Just (+ 1) &lt;*| Just 2
  Just 3
</pre></div></div><h2 id="g:11">Monad</h2><div class="top"><p class="src"><a id="v:flatMap" class="def">flatMap</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b <a href="#v:flatMap" class="selflink">#</a></p><div class="doc"><p>The <code>Monad</code> type class defines that a type
can have an <code><a href="Eta.html#v:flatMap">flatMap</a></code> operation which can be used
to sequence actions over the same type.</p><p>All types that implement <code>Monad</code> must implement
<code>Applicative</code>.</p><p>The List, <code>Maybe</code>, and <code>IO</code> types are examples of
instances of <code>Monad</code>.</p><pre>  &gt;&gt;&gt; flatMap (x -&gt; [1 .. x]) [1, 2, 3]
  [1,1,2,1,2,3]
</pre><p><em>Mnemonic: Sequenceable</em></p></div></div><h3 id="g:12">Flatmap forward</h3><div class="top"><p class="src"><a id="v:-124--62--62-" class="def">(|&gt;&gt;)</a> :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b <a href="#v:-124--62--62-" class="selflink">#</a></p><div class="doc"><p>Flatmaps the function of the right over the Monad of the left</p><pre>  &gt;&gt;&gt; readFile &quot;data.txt&quot; |&gt;&gt; putStrLn
  &quot;This is some data stored in data.txt&quot;
</pre></div></div><h3 id="g:13">Flatmap backwards</h3><div class="top"><p class="src"><a id="v:-60--60--124-" class="def">(&lt;&lt;|)</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b <a href="#v:-60--60--124-" class="selflink">#</a></p><div class="doc"><p>Flatmaps the function of the left over the Monad of the left</p><pre>  &gt;&gt;&gt; putStrLn &lt;&lt;| readFile &quot;data.txt&quot;
  &quot;This is some data stored in data.txt&quot;
</pre></div></div><h2 id="g:14">Monoid</h2><div class="top"><p class="src"><a id="v:append" class="def">append</a> :: Monoid a =&gt; a -&gt; a -&gt; a <a href="#v:append" class="selflink">#</a></p><div class="doc"><p>The <code>Monoid</code> type class defines that a type
can have an <code><a href="Eta.html#v:append">append</a></code> operation which can be used
to append two things of the same type</p><p>The List, and String types are examples of
instances of <code>Monoid</code>.</p><pre>  &gt;&gt;&gt; append &quot;Hello &quot; &quot;world!&quot;
  &quot;Hello world!&quot;
</pre><p><em>Mnemonic: Appendable</em></p></div></div><h3 id="g:15">Monoid neutral element</h3><div class="top"><p class="src"><a id="v:neutral" class="def">neutral</a> :: Monoid a =&gt; a <a href="#v:neutral" class="selflink">#</a></p><div class="doc"><p>A <code>Monoid</code> also requires that the type has a neutral
element that does not affect concatenation.</p><pre>  foo :: String
  foo = neutral

  bar :: [Int]
  bar = neutral

  &gt;&gt;&gt; foo
  &quot;&quot;

  &gt;&gt;&gt; bar
  []
</pre></div></div><h3 id="g:16">Monoid reduction</h3><div class="top"><p class="src"><a id="v:concat" class="def">concat</a> :: Monoid a =&gt; [a] -&gt; a <a href="#v:concat" class="selflink">#</a></p><div class="doc"><p>You can reduce a list of elements that implement the
<code>Monoid</code> type class by using <code><a href="Eta.html#v:concat">concat</a></code></p><pre>  &gt;&gt;&gt; concat [&quot;Hello &quot;, &quot;world &quot;, &quot;!&quot;]
  &quot;Hello world!&quot;
</pre></div></div><h3 id="g:17">Append operator</h3><div class="top"><p class="src"><a id="v:-60--43--62-" class="def">(&lt;+&gt;)</a> :: Monoid a =&gt; a -&gt; a -&gt; a <a href="#v:-60--43--62-" class="selflink">#</a></p><div class="doc"><p>Operator for the <code><a href="Eta.html#v:append">append</a></code> operation</p><pre>  &gt;&gt;&gt; &quot;Hello &quot; &lt;+&gt; &quot;world!&quot;
  &quot;Hello world!&quot;
</pre></div></div><h2 id="g:18">Foldable</h2><div class="top"><p class="src"><a id="v:foldRight" class="def">foldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:foldRight" class="selflink">#</a></p><div class="doc"><p>The <code>Foldable</code> type class defines that a type
can have a <code><a href="Eta.html#v:foldRight">foldRight</a></code> operation which can be used
to reduce it by passing a binary operation and a
neutral element. This reduces starting from the right.</p><p>The List type is an example of <code>Foldable</code></p><pre>  &gt;&gt;&gt; foldRight (+) 0 [1, 2, 3]
  6
</pre><p><em>Mnemonic: Reduceable</em></p></div></div><h3 id="g:19">foldLeft</h3><div class="top"><p class="src"><a id="v:foldLeft" class="def">foldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:foldLeft" class="selflink">#</a></p><div class="doc"><p><code><a href="Eta.html#v:foldLeft">foldLeft</a></code> starts from the left, using the lazy evaluation
capabilities of Eta. Note that this will get stuck in an
infite loop if you pass an infite list to it.</p></div></div><h3 id="g:20">strictFoldRight</h3><div class="top"><p class="src"><a id="v:strictFoldRight" class="def">strictFoldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:strictFoldRight" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Eta.html#v:foldRight">foldRight</a></code> that evaluates the operations inline,
hence <em>strict</em>, the opposite of lazy.</p></div></div><h3 id="g:21">strictFoldLeft</h3><div class="top"><p class="src"><a id="v:strictFoldLeft" class="def">strictFoldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:strictFoldLeft" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Eta.html#v:foldLeft">foldLeft</a></code> that evaluates the operations inline,
hence <em>strict</em>, the opposite of lazy.</p></div></div><h3 id="g:22">monadicFoldRight</h3><div class="top"><p class="src"><a id="v:monadicFoldRight" class="def">monadicFoldRight</a> :: (Foldable f, Monad m) =&gt; (a -&gt; b -&gt; m b) -&gt; b -&gt; f a -&gt; m b <a href="#v:monadicFoldRight" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Eta.html#v:foldRight">foldRight</a></code> that applies functions that are flatmappable,
in the context of a type that implements a monad, and returns the
result produced by the reduction of the structure, wrapped in that type:</p><pre>  &gt;&gt;&gt; addIntoMaybe :: Int -&gt; Int -&gt; Maybe Int
  &gt;&gt;&gt; addIntoMaybe a b = Just (a + b)

  &gt;&gt;&gt; monadicFoldRight addIntoMaybe 0 [1,2,3]
  Just 6
</pre></div></div><h3 id="g:23">monadicFoldLeft</h3><div class="top"><p class="src"><a id="v:monadicFoldLeft" class="def">monadicFoldLeft</a> :: (Foldable f, Monad m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; f a -&gt; m b <a href="#v:monadicFoldLeft" class="selflink">#</a></p><div class="doc"><p>Left-biased version of <code><a href="Eta.html#v:monadicFoldRight">monadicFoldRight</a></code></p></div></div><h3 id="g:24">foldMap</h3><div class="top"><p class="src"><a id="v:foldMap" class="def">foldMap</a> :: (Foldable f, Monoid m) =&gt; (a -&gt; m) -&gt; f a -&gt; m <a href="#v:foldMap" class="selflink">#</a></p><div class="doc"><p><code><a href="Eta.html#v:foldMap">foldMap</a></code> is an operation that first converts all the elements
into a <code>Monoid</code> and then <code><a href="Eta.html#v:foldRight">foldRight</a></code>s them using the <code><a href="Eta.html#v:append">append</a></code> and
<code><a href="Eta.html#v:neutral">neutral</a></code> functions.</p><pre>  -- Converts all the elements to Strings and then folds them
  &gt;&gt;&gt; foldMap show [1, 2, 3]
  &quot;123&quot;
</pre><p>This is the same as doing</p><pre>  &gt;&gt;&gt; [1, 2, 3]
  &gt;&gt;&gt;   |&gt; map show
  &gt;&gt;&gt;   |&gt; foldRight append neutral
  &quot;123&quot;
</pre></div></div><h3 id="g:25">toList</h3><div class="top"><p class="src"><a id="v:toList" class="def">toList</a> :: Foldable f =&gt; f a -&gt; [a] <a href="#v:toList" class="selflink">#</a></p><div class="doc"><p>Converts a type that implements <code>Foldable</code> into a list</p></div></div><h3 id="g:26">isEmpty</h3><div class="top"><p class="src"><a id="v:isEmpty" class="def">isEmpty</a> :: Foldable f =&gt; f a -&gt; Bool <a href="#v:isEmpty" class="selflink">#</a></p><div class="doc"><p>Checks if a <code>Foldable</code> structure is empty.</p></div></div><h3 id="g:27">length</h3><div class="top"><p class="src"><a id="v:length" class="def">length</a> :: Foldable f =&gt; f a -&gt; Int <a href="#v:length" class="selflink">#</a></p><div class="doc"><p>Returns the size of a structure.</p></div></div><h3 id="g:28">isElementOf</h3><div class="top"><p class="src"><a id="v:isElementOf" class="def">isElementOf</a> :: (Eq a, Foldable f) =&gt; a -&gt; f a -&gt; Bool <a href="#v:isElementOf" class="selflink">#</a></p><div class="doc"><p>Checks if the element is contained in the structure.</p></div></div><h3 id="g:29">maximum</h3><div class="top"><p class="src"><a id="v:maximum" class="def">maximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; Maybe a <a href="#v:maximum" class="selflink">#</a></p><div class="doc"><p>Largest element in a structure.
Returns <code>Nothing</code> if the structure is empty.</p></div></div><h3 id="g:30">maximumBy</h3><div class="top"><p class="src"><a id="v:maximumBy" class="def">maximumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; Maybe a <a href="#v:maximumBy" class="selflink">#</a></p><div class="doc"><p>Given some comparison function, return the maximum of a
structure. Returns <code>Nothing</code> if the structure is empty.</p></div></div><h3 id="g:31">unsafeMaximum</h3><div class="top"><p class="src"><a id="v:unsafeMaximum" class="def">unsafeMaximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a <a href="#v:unsafeMaximum" class="selflink">#</a></p><div class="doc"><p>Largest element in a structure.
Errors if the structure is empty</p></div></div><h3 id="g:32">minimum</h3><div class="top"><p class="src"><a id="v:minimum" class="def">minimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; Maybe a <a href="#v:minimum" class="selflink">#</a></p><div class="doc"><p>Smallest element in a structure
Returns <code>Nothing</code> if the structure is empty.</p></div></div><h3 id="g:33">minimumBy</h3><div class="top"><p class="src"><a id="v:minimumBy" class="def">minimumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; Maybe a <a href="#v:minimumBy" class="selflink">#</a></p><div class="doc"><p>Given some comparison function, return the minimum of a
structure. Returns <code>Nothing</code> if the structure is empty.</p></div></div><h3 id="g:34">unsafeMinimum</h3><div class="top"><p class="src"><a id="v:unsafeMinimum" class="def">unsafeMinimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a <a href="#v:unsafeMinimum" class="selflink">#</a></p><div class="doc"><p>Largest element in a structure.
Errors if the structure is empty</p></div></div><h3 id="g:35">sum</h3><div class="top"><p class="src"><a id="v:sum" class="def">sum</a> :: (Num a, Foldable f) =&gt; f a -&gt; a <a href="#v:sum" class="selflink">#</a></p><div class="doc"><p>Sum of the numbers of a structure</p></div></div><h3 id="g:36">product</h3><div class="top"><p class="src"><a id="v:product" class="def">product</a> :: (Num a, Foldable f) =&gt; f a -&gt; a <a href="#v:product" class="selflink">#</a></p><div class="doc"><p>Product of the numbers of a structure</p></div></div><h3 id="g:37">findBy</h3><div class="top"><p class="src"><a id="v:findBy" class="def">findBy</a> :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; Maybe a <a href="#v:findBy" class="selflink">#</a></p><div class="doc"><p>Given some predicate, <code><a href="Eta.html#v:findBy">findBy</a></code> will return
the first element that matches the predicate
or <code>Nothing</code> if there is no such element</p></div></div><h3 id="g:38">any</h3><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; Bool <a href="#v:any" class="selflink">#</a></p><div class="doc"><p>Determines if any element satisfies the predicate</p><pre>  &gt;&gt;&gt; any (== 1) [1, 2, 3]
  True
  &gt;&gt;&gt; any (== 5) [1, 2, 3]
  False
</pre></div></div><h3 id="g:39">all</h3><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; Bool <a href="#v:all" class="selflink">#</a></p><div class="doc"><p>Determines if all elements satisfy the predicate</p><pre>  &gt;&gt;&gt; all (== 1) [1, 2, 3]
  False
  &gt;&gt;&gt; all (&lt; 5) [1, 2, 3]
  False
</pre></div></div><h2 id="g:40">Acting on Foldables</h2><div class="top"><p class="src"><a id="v:discardTraverse" class="def">discardTraverse</a> :: (Foldable f, Applicative m) =&gt; (a -&gt; m b) -&gt; f a -&gt; m () <a href="#v:discardTraverse" class="selflink">#</a></p><div class="doc"><p>Sometimes we need to apply an action to each one of
the elements. The function <code><a href="Eta.html#v:discardTraverse">discardTraverse</a></code> maps an
action over each of the elements of the structure</p><pre>  &gt;&gt;&gt; discardTraverse putStrLn [<a href="Hello.html">Hello</a>, &quot;world&quot;, &quot;!&quot;]
  Hello
  world
  !
</pre></div></div><h3 id="g:41">foreach</h3><div class="top"><p class="src"><a id="v:foreach" class="def">foreach</a> :: (Foldable f, Applicative m) =&gt; f a -&gt; (a -&gt; m b) -&gt; m () <a href="#v:foreach" class="selflink">#</a></p><div class="doc"><p>Another alternative to <code>mapAction</code> is to use the
<code><a href="Eta.html#v:foreach">foreach</a></code> function, which is very familiar to a lot
of developers.</p><pre>  &gt;&gt;&gt; foreach [1..3] $ i -&gt; do
  &gt;&gt;&gt;   let message = &quot;Got number: &quot; <a href="+">+</a> show i
  &gt;&gt;&gt;   putStrLn message
  Got number: 1
  Got number: 2
  Got number: 3
</pre></div></div><h2 id="g:42">Traversable</h2></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.4</p></div></body></html>