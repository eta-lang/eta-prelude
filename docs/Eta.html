<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Eta</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Eta.html");};
//]]>
</script></head><body class="no-frame"><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Eta</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Concepts</a><ul><li><a href="#g:2">Functor</a></li><li><a href="#g:3">Applicative</a><ul><li><a href="#g:4">Apply forward</a></li><li><a href="#g:5">Apply backwards</a></li></ul></li><li><a href="#g:6">Monad</a><ul><li><a href="#g:7">Flatmap forward</a></li><li><a href="#g:8">Flatmap backwards</a></li></ul></li><li><a href="#g:9">Foldable</a><ul><li><a href="#g:10">foldMap</a></li></ul></li><li><a href="#g:11">Acting on Foldables</a><ul><li><a href="#g:12">foreach</a></li></ul></li><li><a href="#g:13">Traversable</a></li></ul></li><li><a href="#g:14">String manipulation</a><ul><li><a href="#g:15">Basic (de)serializing</a></li><li><a href="#g:16">String operations</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The Eta</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:apply">apply</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-124--42--62-">(|*&gt;)</a> :: Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b</li><li class="src short"><a href="#v:-60--42--124-">(&lt;*|)</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:flatMap">flatMap</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</li><li class="src short"><a href="#v:-124--62--62-">(|&gt;&gt;)</a> :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:-60--60--124-">(&lt;&lt;|)</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</li><li class="src short"><a href="#v:foldRight">foldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:foldLeft">foldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:strictFoldRight">strictFoldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:strictFoldLeft">strictFoldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b</li><li class="src short"><a href="#v:monadicFoldRight">monadicFoldRight</a> :: (Foldable f, Monad m) =&gt; (a -&gt; b -&gt; m b) -&gt; b -&gt; f a -&gt; m b</li><li class="src short"><a href="#v:monadicFoldLeft">monadicFoldLeft</a> :: (Foldable f, Monad m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; f a -&gt; m b</li><li class="src short"><a href="#v:foldMap">foldMap</a> :: (Foldable f, Monoid m) =&gt; (a -&gt; m) -&gt; f a -&gt; m</li><li class="src short"><a href="#v:toList">toList</a> :: Foldable f =&gt; f a -&gt; [a]</li><li class="src short"><a href="#v:isEmpty">isEmpty</a> :: Foldable f =&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:length">length</a> :: Foldable f =&gt; f a -&gt; Int</li><li class="src short"><a href="#v:isElementOf">isElementOf</a> :: (Eq a, Foldable f) =&gt; a -&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:maximum">maximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:maximumBy">maximumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:unsafeMaximum">unsafeMaximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:minimum">minimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:minimumBy">minimumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:unsafeMinimum">unsafeMinimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:sum">sum</a> :: (Num a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:product">product</a> :: (Num a, Foldable f) =&gt; f a -&gt; a</li><li class="src short"><a href="#v:findBy">findBy</a> :: Foldable f =&gt; (a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a>) -&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:any">any</a> :: Foldable f =&gt; (a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a>) -&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:all">all</a> :: Foldable f =&gt; (a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a>) -&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:discardTraverse">discardTraverse</a> :: (Foldable f, Applicative m) =&gt; (a -&gt; m b) -&gt; f a -&gt; m ()</li><li class="src short"><a href="#v:foreach">foreach</a> :: (Foldable f, Applicative m) =&gt; f a -&gt; (a -&gt; m b) -&gt; m ()</li><li class="src short"><a href="#v:traverse">traverse</a> :: (Traversable t, Applicative m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)</li><li class="src short"><a href="#v:for">for</a> :: (Traversable t, Applicative m) =&gt; t a -&gt; (a -&gt; m b) -&gt; m (t b)</li><li class="src short"><a href="#v:sequence">sequence</a> :: (Traversable t, Applicative m) =&gt; t (m a) -&gt; m (t a)</li><li class="src short"><a href="#v:show">show</a> :: Show a =&gt; a -&gt; String</li><li class="src short"><a href="#v:read">read</a> :: Read a =&gt; String -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:unsafeRead">unsafeRead</a> :: Read a =&gt; String -&gt; a</li><li class="src short"><a href="#v:lines">lines</a> :: String -&gt; [String]</li><li class="src short"><a href="#v:unlines">unlines</a> :: [String] -&gt; String</li><li class="src short"><a href="#v:words">words</a> :: String -&gt; [String]</li><li class="src short"><a href="#v:unwords">unwords</a> :: [String] -&gt; String</li></ul></div><div id="interface"><h1 id="g:1">Concepts</h1><h2 id="g:2">Functor</h2><h2 id="g:3">Applicative</h2><div class="top"><p class="src"><a id="v:apply" class="def">apply</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b <a href="#v:apply" class="selflink">#</a></p><div class="doc"><p>The <code>Applicative</code> type class defines that a type
can have an <code><a href="Eta.html#v:apply">apply</a></code> operation which can be used
to apply a function contained in the <code>Applicative</code>
to the elements of Another.</p><p>All types that implement <code>Applicative</code> must implement
<code>Functor</code>.</p><p>The <code><a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a></code> type is an example of
an instance of <code>Applicative</code>.</p><pre>  &gt;&gt;&gt; apply (Just (+1)) (Just 2)
  Just 3
</pre><p><em>Mnemonic: Applyable</em></p></div></div><h3 id="g:4">Apply forward</h3><div class="top"><p class="src"><a id="v:-124--42--62-" class="def">(|*&gt;)</a> :: Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b <a href="#v:-124--42--62-" class="selflink">#</a></p><div class="doc"><p>Applies the function contained in the Applicative of the right
to the Applicative which contains a value of the left:</p><pre>  &gt;&gt;&gt; Just 1 |*&gt; Just (+2)
  Just 3
</pre></div></div><h3 id="g:5">Apply backwards</h3><div class="top"><p class="src"><a id="v:-60--42--124-" class="def">(&lt;*|)</a> :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b <a href="#v:-60--42--124-" class="selflink">#</a></p><div class="doc"><p>Applies the function contained in the Applicative of the left
to the Applicative which contains a value of the right:</p><pre>  &gt;&gt;&gt; Just (+ 1) &lt;*| Just 2
  Just 3
</pre></div></div><h2 id="g:6">Monad</h2><div class="top"><p class="src"><a id="v:flatMap" class="def">flatMap</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b <a href="#v:flatMap" class="selflink">#</a></p><div class="doc"><p>The <code>Monad</code> type class defines that a type
can have an <code><a href="Eta.html#v:flatMap">flatMap</a></code> operation which can be used
to sequence actions over the same type.</p><p>All types that implement <code>Monad</code> must implement
<code>Applicative</code>.</p><p>The List, <code><a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a></code>, and <code><a href="Eta-Types-IO.html#t:IO">IO</a></code> types are examples of
instances of <code>Monad</code>.</p><pre>  &gt;&gt;&gt; flatMap (x -&gt; [1 .. x]) [1, 2, 3]
  [1,1,2,1,2,3]
</pre><p><em>Mnemonic: Sequenceable</em></p></div></div><h3 id="g:7">Flatmap forward</h3><div class="top"><p class="src"><a id="v:-124--62--62-" class="def">(|&gt;&gt;)</a> :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b <a href="#v:-124--62--62-" class="selflink">#</a></p><div class="doc"><p>Flatmaps the function of the right over the Monad of the left</p><pre>  &gt;&gt;&gt; readFile &quot;data.txt&quot; |&gt;&gt; printLine
  &quot;This is some data stored in data.txt&quot;
</pre></div></div><h3 id="g:8">Flatmap backwards</h3><div class="top"><p class="src"><a id="v:-60--60--124-" class="def">(&lt;&lt;|)</a> :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b <a href="#v:-60--60--124-" class="selflink">#</a></p><div class="doc"><p>Flatmaps the function of the left over the Monad of the left</p><pre>  &gt;&gt;&gt; printLine &lt;&lt;| readFile &quot;data.txt&quot;
  &quot;This is some data stored in data.txt&quot;
</pre></div></div><h2 id="g:9">Foldable</h2><div class="top"><p class="src"><a id="v:foldRight" class="def">foldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:foldRight" class="selflink">#</a></p><div class="doc"><p>The <code>Foldable</code> type class defines that a type
can have a <code><a href="Eta.html#v:foldRight">foldRight</a></code> operation which can be used
to reduce it by passing a binary operation and a
neutral element. This reduces starting from the right.</p><p>The List type is an example of <code>Foldable</code></p><pre>  &gt;&gt;&gt; foldRight (+) 0 [1, 2, 3]
  6
</pre><p><em>Mnemonic: Reduceable</em></p></div></div><div class="top"><p class="src"><a id="v:foldLeft" class="def">foldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:foldLeft" class="selflink">#</a></p><div class="doc"><p><code><a href="Eta.html#v:foldLeft">foldLeft</a></code> starts from the left, using the lazy evaluation
capabilities of Eta. Note that this will get stuck in an
infite loop if you pass an infite list to it.</p></div></div><div class="top"><p class="src"><a id="v:strictFoldRight" class="def">strictFoldRight</a> :: Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:strictFoldRight" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Eta.html#v:foldRight">foldRight</a></code> that evaluates the operations inline,
hence <em>strict</em>, the opposite of lazy.</p></div></div><div class="top"><p class="src"><a id="v:strictFoldLeft" class="def">strictFoldLeft</a> :: Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b <a href="#v:strictFoldLeft" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Eta.html#v:foldLeft">foldLeft</a></code> that evaluates the operations inline,
hence <em>strict</em>, the opposite of lazy.</p></div></div><div class="top"><p class="src"><a id="v:monadicFoldRight" class="def">monadicFoldRight</a> :: (Foldable f, Monad m) =&gt; (a -&gt; b -&gt; m b) -&gt; b -&gt; f a -&gt; m b <a href="#v:monadicFoldRight" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Eta.html#v:foldRight">foldRight</a></code> that applies functions that are flatmappable,
in the context of a type that implements a monad, and returns the
result produced by the reduction of the structure, wrapped in that type:</p><pre>  &gt;&gt;&gt; addIntoMaybe :: Int -&gt; Int -&gt; Maybe Int
  &gt;&gt;&gt; addIntoMaybe a b = Just (a + b)

  &gt;&gt;&gt; monadicFoldRight addIntoMaybe 0 [1,2,3]
  Just 6
</pre></div></div><div class="top"><p class="src"><a id="v:monadicFoldLeft" class="def">monadicFoldLeft</a> :: (Foldable f, Monad m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; f a -&gt; m b <a href="#v:monadicFoldLeft" class="selflink">#</a></p><div class="doc"><p>Left-biased version of <code><a href="Eta.html#v:monadicFoldRight">monadicFoldRight</a></code></p></div></div><h3 id="g:10">foldMap</h3><div class="top"><p class="src"><a id="v:foldMap" class="def">foldMap</a> :: (Foldable f, Monoid m) =&gt; (a -&gt; m) -&gt; f a -&gt; m <a href="#v:foldMap" class="selflink">#</a></p><div class="doc"><p><code><a href="Eta.html#v:foldMap">foldMap</a></code> is an operation that first converts all the elements
into a <code>Monoid</code> and then <code><a href="Eta.html#v:foldRight">foldRight</a></code>s them using the <code>append</code> and
<code>neutral</code> functions.</p><pre>  -- Converts all the elements to Strings and then folds them
  &gt;&gt;&gt; foldMap show [1, 2, 3]
  &quot;123&quot;
</pre><p>This is the same as doing</p><pre>  &gt;&gt;&gt; [1, 2, 3]
  &gt;&gt;&gt;   |&gt; map show
  &gt;&gt;&gt;   |&gt; foldRight append neutral
  &quot;123&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:toList" class="def">toList</a> :: Foldable f =&gt; f a -&gt; [a] <a href="#v:toList" class="selflink">#</a></p><div class="doc"><p>Converts a type that implements <code>Foldable</code> into a list</p></div></div><div class="top"><p class="src"><a id="v:isEmpty" class="def">isEmpty</a> :: Foldable f =&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a> <a href="#v:isEmpty" class="selflink">#</a></p><div class="doc"><p>Checks if a <code>Foldable</code> structure is empty.</p></div></div><div class="top"><p class="src"><a id="v:length" class="def">length</a> :: Foldable f =&gt; f a -&gt; Int <a href="#v:length" class="selflink">#</a></p><div class="doc"><p>Returns the size of a structure.</p></div></div><div class="top"><p class="src"><a id="v:isElementOf" class="def">isElementOf</a> :: (Eq a, Foldable f) =&gt; a -&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a> <a href="#v:isElementOf" class="selflink">#</a></p><div class="doc"><p>Checks if the element is contained in the structure.</p></div></div><div class="top"><p class="src"><a id="v:maximum" class="def">maximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a <a href="#v:maximum" class="selflink">#</a></p><div class="doc"><p>Largest element in a structure.
Returns <code><a href="Eta-Types-Maybe.html#v:Nothing">Nothing</a></code> if the structure is empty.</p></div></div><div class="top"><p class="src"><a id="v:maximumBy" class="def">maximumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a <a href="#v:maximumBy" class="selflink">#</a></p><div class="doc"><p>Given some comparison function, return the maximum of a
structure. Returns <code><a href="Eta-Types-Maybe.html#v:Nothing">Nothing</a></code> if the structure is empty.</p></div></div><div class="top"><p class="src"><a id="v:unsafeMaximum" class="def">unsafeMaximum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a <a href="#v:unsafeMaximum" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Warning: unsafeMaximum detected: Partial functions should be avoided</p></div><p>Largest element in a structure.
Errors if the structure is empty</p></div></div><div class="top"><p class="src"><a id="v:minimum" class="def">minimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a <a href="#v:minimum" class="selflink">#</a></p><div class="doc"><p>Smallest element in a structure
Returns <code><a href="Eta-Types-Maybe.html#v:Nothing">Nothing</a></code> if the structure is empty.</p></div></div><div class="top"><p class="src"><a id="v:minimumBy" class="def">minimumBy</a> :: Foldable f =&gt; (a -&gt; a -&gt; Ordering) -&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a <a href="#v:minimumBy" class="selflink">#</a></p><div class="doc"><p>Given some comparison function, return the minimum of a
structure. Returns <code><a href="Eta-Types-Maybe.html#v:Nothing">Nothing</a></code> if the structure is empty.</p></div></div><div class="top"><p class="src"><a id="v:unsafeMinimum" class="def">unsafeMinimum</a> :: (Ord a, Foldable f) =&gt; f a -&gt; a <a href="#v:unsafeMinimum" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Warning: unsafeMinimum detected: Partial functions should be avoided</p></div><p>Largest element in a structure.
Errors if the structure is empty</p></div></div><div class="top"><p class="src"><a id="v:sum" class="def">sum</a> :: (Num a, Foldable f) =&gt; f a -&gt; a <a href="#v:sum" class="selflink">#</a></p><div class="doc"><p>Sum of the numbers of a structure</p></div></div><div class="top"><p class="src"><a id="v:product" class="def">product</a> :: (Num a, Foldable f) =&gt; f a -&gt; a <a href="#v:product" class="selflink">#</a></p><div class="doc"><p>Product of the numbers of a structure</p></div></div><div class="top"><p class="src"><a id="v:findBy" class="def">findBy</a> :: Foldable f =&gt; (a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a>) -&gt; f a -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a <a href="#v:findBy" class="selflink">#</a></p><div class="doc"><p>Given some predicate, <code><a href="Eta.html#v:findBy">findBy</a></code> will return
the first element that matches the predicate
or <code><a href="Eta-Types-Maybe.html#v:Nothing">Nothing</a></code> if there is no such element</p></div></div><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: Foldable f =&gt; (a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a>) -&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a> <a href="#v:any" class="selflink">#</a></p><div class="doc"><p>Determines if any element satisfies the predicate</p><pre>  &gt;&gt;&gt; any (== 1) [1, 2, 3]
  True
  &gt;&gt;&gt; any (== 5) [1, 2, 3]
  False
</pre></div></div><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: Foldable f =&gt; (a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a>) -&gt; f a -&gt; <a href="Eta-Types-Bool.html#t:Bool">Bool</a> <a href="#v:all" class="selflink">#</a></p><div class="doc"><p>Determines if all elements satisfy the predicate</p><pre>  &gt;&gt;&gt; all (== 1) [1, 2, 3]
  False
  &gt;&gt;&gt; all (&lt; 5) [1, 2, 3]
  False
</pre></div></div><h2 id="g:11">Acting on Foldables</h2><div class="top"><p class="src"><a id="v:discardTraverse" class="def">discardTraverse</a> :: (Foldable f, Applicative m) =&gt; (a -&gt; m b) -&gt; f a -&gt; m () <a href="#v:discardTraverse" class="selflink">#</a></p><div class="doc"><p>Sometimes we need to apply an action to each one of
the elements. The function <code><a href="Eta.html#v:discardTraverse">discardTraverse</a></code> maps an
action over each of the elements of the structure</p><pre>  &gt;&gt;&gt; discardTraverse printLine [&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;]
  Hello
  world
  !
</pre></div></div><h3 id="g:12">foreach</h3><div class="top"><p class="src"><a id="v:foreach" class="def">foreach</a> :: (Foldable f, Applicative m) =&gt; f a -&gt; (a -&gt; m b) -&gt; m () <a href="#v:foreach" class="selflink">#</a></p><div class="doc"><p>Another alternative to <code><a href="Eta.html#v:discardTraverse">discardTraverse</a></code> is to use the
<code><a href="Eta.html#v:foreach">foreach</a></code> function, which is very familiar to a lot
of developers.</p><pre>  &gt;&gt;&gt; foreach [1..3] $ i -&gt; do
  &gt;&gt;&gt;   let message = &quot;Got number: &quot; &lt;+&gt; show i
  &gt;&gt;&gt;   printLine message
  Got number: 1
  Got number: 2
  Got number: 3
</pre></div></div><h2 id="g:13">Traversable</h2><div class="top"><p class="src"><a id="v:traverse" class="def">traverse</a> :: (Traversable t, Applicative m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b) <a href="#v:traverse" class="selflink">#</a></p><div class="doc"><p>The <code>Traversable</code> type class defines that a structure
can be traversed from left to right, applying some
flatmappable function to it.</p><pre>  &gt;&gt;&gt; traverse readFile [&quot;foo.txt&quot;, &quot;bar.txt&quot;, &quot;quux.txt&quot;]
  [&quot;foo contents&quot; , &quot;bar contents&quot;, &quot;quux contents&quot;]
</pre><p>It basically applies the actions inside of the type that
the passed returns, and collects them, unless it fails.</p><pre>  &gt;&gt;&gt; safeDivide a b =
  &gt;&gt;&gt;     if b == 0
  &gt;&gt;&gt;     then Nothing
  &gt;&gt;&gt;     else Just (a / b)

  &gt;&gt;&gt; traverse (safeDivide 2) [1, 2]
  Just [2, 1]

  &gt;&gt;&gt; traverse (safeDivide 2) [0, 2]
  Nothing
</pre></div></div><div class="top"><p class="src"><a id="v:for" class="def">for</a> :: (Traversable t, Applicative m) =&gt; t a -&gt; (a -&gt; m b) -&gt; m (t b) <a href="#v:for" class="selflink">#</a></p><div class="doc"><p><code><a href="Eta.html#v:traverse">traverse</a></code> with the arguments flipped, allows to work in an imperative manner,
like with <code><a href="Eta.html#v:foreach">foreach</a></code>:</p><pre>  &gt;&gt;&gt; for [1..3] $ i -&gt; do
  &gt;&gt;&gt;     let x = i + 1
  &gt;&gt;&gt;     Just x
  Just [2, 3, 4]
</pre></div></div><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: (Traversable t, Applicative m) =&gt; t (m a) -&gt; m (t a) <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><p><code><a href="Eta.html#v:sequence">sequence</a></code> moves the context of each of the elements of
a <code>Traversable</code> structure to the structure itself</p><pre>  &gt;&gt;&gt; sequence [Just 1, Just 2]
  Just [1, 2]

  &gt;&gt;&gt; sequence [Just 1, Nothing]
  Nothing
</pre></div></div><h1 id="g:14">String manipulation</h1><h2 id="g:15">Basic (de)serializing</h2><div class="top"><p class="src"><a id="v:show" class="def">show</a> :: Show a =&gt; a -&gt; String <a href="#v:show" class="selflink">#</a></p><div class="doc"><p>The <code>Show</code> type class denotes that a type
can be converted to a <code>String</code>, like the
<code>toString</code> method from Java.</p></div></div><div class="top"><p class="src"><a id="v:read" class="def">read</a> :: Read a =&gt; String -&gt; <a href="Eta-Types-Maybe.html#t:Maybe">Maybe</a> a <a href="#v:read" class="selflink">#</a></p><div class="doc"><p>The <code>Read</code> type class denotes that a type
can be converted from a <code>String</code>.</p><p>This is useful when in need of some basic
deserialization:</p><pre>  &gt;&gt;&gt; read &quot;1&quot; :: Int
  Just 1

  &gt;&gt;&gt; read &quot;hotdog&quot; :: Int
  Nothing
</pre></div></div><div class="top"><p class="src"><a id="v:unsafeRead" class="def">unsafeRead</a> :: Read a =&gt; String -&gt; a <a href="#v:unsafeRead" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Warning: unsafeRead detected: Partial functions should be avoided</p></div><p><code><a href="Eta.html#v:read">read</a></code>s a <code>String</code>, but instead of returning
<code><a href="Eta-Types-Maybe.html#v:Nothing">Nothing</a></code> on parse error, it fails.</p></div></div><h2 id="g:16">String operations</h2><div class="top"><p class="src"><a id="v:lines" class="def">lines</a> :: String -&gt; [String] <a href="#v:lines" class="selflink">#</a></p><div class="doc"><p>Breaks a <code>String</code> into a '[String]' at newline <code>Char</code>s</p><pre>  &gt;&gt;&gt; lines &quot;Hello\nI'm Joe&quot;
  [<a href="Hello.html">Hello</a>, &quot;I'm Joe&quot;]
</pre></div></div><div class="top"><p class="src"><a id="v:unlines" class="def">unlines</a> :: [String] -&gt; String <a href="#v:unlines" class="selflink">#</a></p><div class="doc"><p>Joins a '[String]' appending a newline to each element</p><pre>  &gt;&gt;&gt; unlines [&quot;Hello&quot;, &quot;I'm Joe&quot;]
  &quot;Hello\nI'm Joe&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:words" class="def">words</a> :: String -&gt; [String] <a href="#v:words" class="selflink">#</a></p><div class="doc"><p>Splits a <code>String</code> into a '[String]' at <code>Char</code>s representing
white spaces.</p><pre>  &gt;&gt;&gt; words &quot;How are you&quot;
  [<a href="How.html">How</a>, &quot;are&quot;, &quot;you&quot;]
</pre></div></div><div class="top"><p class="src"><a id="v:unwords" class="def">unwords</a> :: [String] -&gt; String <a href="#v:unwords" class="selflink">#</a></p><div class="doc"><p>Joins a '[String]' appending a space to each element</p><pre>  &gt;&gt;&gt; unwords [<a href="How.html">How</a>, &quot;are&quot;, &quot;you&quot;]
  &quot;How are you&quot;
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.4</p></div></body></html>